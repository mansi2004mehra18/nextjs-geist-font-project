{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/lib/books.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\n\nexport interface Book {\n  id: string;\n  title: string;\n  author: string;\n  isbn: string;\n  publicationDate: string;\n  genre: string;\n  description: string;\n  coverImageUrl?: string;\n  readingStatus?: 'unread' | 'reading' | 'read';\n  rating?: number;\n  review?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nconst BOOKS_FILE_PATH = path.join(process.cwd(), 'data', 'books.json');\n\nexport async function getBooks(): Promise<Book[]> {\n  try {\n    const data = await fs.readFile(BOOKS_FILE_PATH, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Error reading books file:', error);\n    // If file doesn't exist, return empty array\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return [];\n    }\n    throw new Error('Failed to read books data');\n  }\n}\n\nexport async function getBookById(id: string): Promise<Book | null> {\n  try {\n    const books = await getBooks();\n    return books.find(book => book.id === id) || null;\n  } catch (error) {\n    console.error('Error getting book by ID:', error);\n    return null;\n  }\n}\n\nexport async function createBook(bookData: Omit<Book, 'id' | 'createdAt' | 'updatedAt'>): Promise<Book> {\n  try {\n    const books = await getBooks();\n    const newBook: Book = {\n      ...bookData,\n      id: Date.now().toString(),\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    books.push(newBook);\n    await fs.writeFile(BOOKS_FILE_PATH, JSON.stringify(books, null, 2));\n    return newBook;\n  } catch (error) {\n    console.error('Error creating book:', error);\n    throw new Error('Failed to create book');\n  }\n}\n\nexport async function updateBook(id: string, updatedData: Partial<Omit<Book, 'id' | 'createdAt'>>): Promise<Book | null> {\n  try {\n    const books = await getBooks();\n    const bookIndex = books.findIndex(book => book.id === id);\n    \n    if (bookIndex === -1) {\n      return null;\n    }\n    \n    books[bookIndex] = {\n      ...books[bookIndex],\n      ...updatedData,\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await fs.writeFile(BOOKS_FILE_PATH, JSON.stringify(books, null, 2));\n    return books[bookIndex];\n  } catch (error) {\n    console.error('Error updating book:', error);\n    throw new Error('Failed to update book');\n  }\n}\n\nexport async function deleteBook(id: string): Promise<boolean> {\n  try {\n    const books = await getBooks();\n    const bookIndex = books.findIndex(book => book.id === id);\n    \n    if (bookIndex === -1) {\n      return false;\n    }\n    \n    books.splice(bookIndex, 1);\n    await fs.writeFile(BOOKS_FILE_PATH, JSON.stringify(books, null, 2));\n    return true;\n  } catch (error) {\n    console.error('Error deleting book:', error);\n    throw new Error('Failed to delete book');\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AAkBA,MAAM,kBAAkB,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;AAElD,eAAe;IACpB,IAAI;QACF,MAAM,OAAO,MAAM,qHAAA,CAAA,UAAE,CAAC,QAAQ,CAAC,iBAAiB;QAChD,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,4CAA4C;QAC5C,IAAI,AAAC,MAAgC,IAAI,KAAK,UAAU;YACtD,OAAO,EAAE;QACX;QACA,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,eAAe,YAAY,EAAU;IAC1C,IAAI;QACF,MAAM,QAAQ,MAAM;QACpB,OAAO,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK,OAAO;IAC/C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACT;AACF;AAEO,eAAe,WAAW,QAAsD;IACrF,IAAI;QACF,MAAM,QAAQ,MAAM;QACpB,MAAM,UAAgB;YACpB,GAAG,QAAQ;YACX,IAAI,KAAK,GAAG,GAAG,QAAQ;YACvB,WAAW,IAAI,OAAO,WAAW;YACjC,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,MAAM,IAAI,CAAC;QACX,MAAM,qHAAA,CAAA,UAAE,CAAC,SAAS,CAAC,iBAAiB,KAAK,SAAS,CAAC,OAAO,MAAM;QAChE,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,eAAe,WAAW,EAAU,EAAE,WAAoD;IAC/F,IAAI;QACF,MAAM,QAAQ,MAAM;QACpB,MAAM,YAAY,MAAM,SAAS,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;QAEtD,IAAI,cAAc,CAAC,GAAG;YACpB,OAAO;QACT;QAEA,KAAK,CAAC,UAAU,GAAG;YACjB,GAAG,KAAK,CAAC,UAAU;YACnB,GAAG,WAAW;YACd,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,MAAM,qHAAA,CAAA,UAAE,CAAC,SAAS,CAAC,iBAAiB,KAAK,SAAS,CAAC,OAAO,MAAM;QAChE,OAAO,KAAK,CAAC,UAAU;IACzB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,eAAe,WAAW,EAAU;IACzC,IAAI;QACF,MAAM,QAAQ,MAAM;QACpB,MAAM,YAAY,MAAM,SAAS,CAAC,CAAA,OAAQ,KAAK,EAAE,KAAK;QAEtD,IAAI,cAAc,CAAC,GAAG;YACpB,OAAO;QACT;QAEA,MAAM,MAAM,CAAC,WAAW;QACxB,MAAM,qHAAA,CAAA,UAAE,CAAC,SAAS,CAAC,iBAAiB,KAAK,SAAS,CAAC,OAAO,MAAM;QAChE,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,MAAM,IAAI,MAAM;IAClB;AACF","debugId":null}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/app/api/books/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getBooks, createBook, Book } from '@/lib/books';\n\nexport async function GET() {\n  try {\n    const books = await getBooks();\n    return NextResponse.json(books);\n  } catch (error) {\n    console.error('Error fetching books:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch books' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    \n    // Validate required fields\n    const requiredFields = ['title', 'author', 'isbn', 'publicationDate', 'genre', 'description'];\n    const missingFields = requiredFields.filter(field => !body[field]);\n    \n    if (missingFields.length > 0) {\n      return NextResponse.json(\n        { error: `Missing required fields: ${missingFields.join(', ')}` },\n        { status: 400 }\n      );\n    }\n\n    const bookData: Omit<Book, 'id' | 'createdAt' | 'updatedAt'> = {\n      title: body.title,\n      author: body.author,\n      isbn: body.isbn,\n      publicationDate: body.publicationDate,\n      genre: body.genre,\n      description: body.description,\n      coverImageUrl: body.coverImageUrl || '',\n      readingStatus: body.readingStatus || 'unread',\n      rating: body.rating || undefined,\n      review: body.review || undefined,\n    };\n\n    const newBook = await createBook(bookData);\n    return NextResponse.json(newBook, { status: 201 });\n  } catch (error) {\n    console.error('Error creating book:', error);\n    return NextResponse.json(\n      { error: 'Failed to create book' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,QAAQ,MAAM,CAAA,GAAA,qHAAA,CAAA,WAAQ,AAAD;QAC3B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,2BAA2B;QAC3B,MAAM,iBAAiB;YAAC;YAAS;YAAU;YAAQ;YAAmB;YAAS;SAAc;QAC7F,MAAM,gBAAgB,eAAe,MAAM,CAAC,CAAA,QAAS,CAAC,IAAI,CAAC,MAAM;QAEjE,IAAI,cAAc,MAAM,GAAG,GAAG;YAC5B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,CAAC,yBAAyB,EAAE,cAAc,IAAI,CAAC,OAAO;YAAC,GAChE;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,WAAyD;YAC7D,OAAO,KAAK,KAAK;YACjB,QAAQ,KAAK,MAAM;YACnB,MAAM,KAAK,IAAI;YACf,iBAAiB,KAAK,eAAe;YACrC,OAAO,KAAK,KAAK;YACjB,aAAa,KAAK,WAAW;YAC7B,eAAe,KAAK,aAAa,IAAI;YACrC,eAAe,KAAK,aAAa,IAAI;YACrC,QAAQ,KAAK,MAAM,IAAI;YACvB,QAAQ,KAAK,MAAM,IAAI;QACzB;QAEA,MAAM,UAAU,MAAM,CAAA,GAAA,qHAAA,CAAA,aAAU,AAAD,EAAE;QACjC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,SAAS;YAAE,QAAQ;QAAI;IAClD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}